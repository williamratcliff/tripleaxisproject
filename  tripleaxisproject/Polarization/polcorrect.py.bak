import numpy as N
import pylab
import math
import readncnr
import writebt7
import copy
import ctypes
import cstruct
from ctypes import c_void_p, c_int, c_long, c_char, c_char_p,c_double,c_ulong
from ctypes import byref as _ref
c_void_pp = ctypes.POINTER(c_void_p)
c_char_pp = ctypes.POINTER(c_char_p)
c_int_p = ctypes.POINTER(c_int)
c_long_p=ctypes.POINTER(c_long)
c_double_p=ctypes.POINTER(c_double)
c_ulong_p=ctypes.POINTER(c_ulong)
#cellP="PcellBT7Jan072008.txt"
#cellA="AcellBT7Jan72008.txt"
cellP="PcellBT7Jan92008.txt"
cellA="AcellBT7Jan92008.txt"


#CTYPES STUFF

##PBdatapt = cstruct.cstruct(('sec',N.float64,(4,1)),('Y',N.float64,(4,1)),
##                    ('Yesq',N.float64,(4,1)),('lambI',N.float64,(4,1)),
##                    ('lamF',N.float64,(4,1)),('C',N.float64,(4,4)),
##                    ('Cesq',N.float64,(4,4)),('S',N.float64,(4,1)),
##                    ('Sesq',N.float64,(4,1)),('NActive',N.float64,(4,1)),
##                    ('activeEq',N.float64,(4,1)),('Nfree',N.intc),
##                    ('freeS',numpy.intc))


class PBindata(ctypes.Structure):
    _fields_=[("Ei",c_double_p),
            ("Ef",c_double_p),
            ("Cpp",c_double_p),
            ("Cmm",c_double_p),
            ("Cpm",c_double_p),
            ("Cmp",c_double_p),
            ("Epp",c_double_p),
            ("Emm",c_double_p),
            ("Epm",c_double_p),
            ("Emp",c_double_p),
            ("tpp",c_ulong_p),
            ("tmm",c_ulong_p),
            ("tpm",c_ulong_p),
            ("tmp",c_ulong_p)
            ]

#typedef struct {
#  double *Ei, *Ef ;
#  double *Cpp, *Cmm, *Cpm, *Cmp ;
#  double *Epp, *Emm, *Epm, *Emp ;
#  unsigned long *tpp, *tmm, *tpm, *tmp ;
#} PBindata ;

class PBoutdata(ctypes.Structure):
    _fields_=[("Spp",c_double_p),
            ("Smm",c_double_p),
            ("Spm",c_double_p),
            ("Smp",c_double_p),
            ("Epp",c_double_p),
            ("Emm",c_double_p),
            ("Epm",c_double_p),
            ("Emp",c_double_p)
            ]

#typedef struct {
#  double *Spp, *Smm, *Spm, *Smp ;
#  double *Epp, *Emm, *Epm, *Emp ;
#} PBoutdata ;

##class PBflags(ctypes.Structure):
##    _fields_=[("MonitorCorrect",c_int),
##            ("PolMonitorCorrect",c_int),
##            ("Debug",c_int),
##            ("SimFlux",c_int),
##            ("SimDeviate",c_int),
##            ("CountsEnable",c_int_p),
##            ("CountsAdd1",c_int_p),
##            ("CountsAdd2",c_int_p),
##            ("Sconstrain",c_int_p),
##            ("Spp",c_double_p),
##            ("Smm",c_double_p),
##            ("Spm",c_double_p),
##            ("Smp",c_double_p)
##            ]

PBflags=cstruct.cstruct(('MonitorCorrect',N.intc),
                    ('PolMonitorCorrect',N.intc),
                    ('Debug',N.intc),
                    ('SimFlux',N.intc),
                    ('SimDeviate',N.intc),
                    ('CountsEnable',int,(1,4)),
                    ('CountsAdd1',int,(1,4)),
                    ('CountsAdd2',int,(1,4)),
                    ('Sconstrain',int,(1,4)),
                    ('Spp','float64',(1,4)),
                    ('Smm','float64',(1,4)),
                    ('Spm','float64',(1,4)),
                    ('Smp','float64',(1,4))
                    )
                    
                    


#typedef struct {
#  int MonitorCorrect ;
#  int PolMonitorCorrect ;
#  int Debug ;
#  int SimFlux ;
#  int SimDeviate ;
#  int CountsEnable[4] ;
#  int CountsAdd1[4] ;
#  int CountsAdd2[4] ;
#  int Sconstrain[4] ;
#  double Spp[4], Smm[4], Spm[4], Smp[4] ;
#} PBflags ;


#/* entrypoints */

#int PBcorrectData(char *PCellFile, char *ACellFile, PBflags *flgs,
#		  int npts, PBindata *in, PBoutdata *out) ;
#int PBsim(char *filename) ;
#int PBreadflags(char *filename) ;

mypolcorrect = N.ctypeslib.load_library('polarization2.dll', '.')




def autovectorized(f):
     """Function decorator to do vectorization only as necessary.
     vectorized functions fail for scalar inputs."""
     def wrapper(input):
         if N.isscalar(input)==False:
             return N.vectorize(f)(input)
         return f(input)
     return wrapper



@autovectorized
def myradians(x):
    return math.radians(x)

def calc_energy(angle,dspace):
    anglerad=myradians(angle)
    tau=2*N.pi/dspace
    k=tau/N.sqrt(2-2*N.cos(anglerad))
    energy=2.072142*k*k
    return energy

class polarization_correct:
    def __init__(self,files):
        self.mydata={}
        self.counts={}
        self.errors={}
        ei=[]
        ef=[]
        self.timestamp={}
        self.files=files
        for key,myfilestr in files.iteritems():
            mydatareader=readncnr.datareader()
            self.mydata[key]=mydatareader.readbuffer(myfilestr)
            #print mydata[key].metadata
            self.counts[key]=N.array(self.mydata[key].data[self.mydata[key].metadata['signal']])
            self.errors[key]=N.sqrt(self.counts[key])
            self.timestamp[key]=N.array(self.mydata[key].data['timestamp'])
            #TODO currently, we assume that the files are taken at the same points--is this safe?
            self.length=self.counts[key].shape[0]
            a2=N.array(self.mydata[key].data['a2'])
            if self.mydata[key].metadata['analyzerdetectormode'].lower()=='diffdet':
                #a6=N.array(mydata[key].data['A5'])*2.0
                a6=a2
            else:
                a6=N.array(self.mydata[key].data['a6'])
            #TODO who's bright idea was it to have A6 listed as "IN"
            #TODO we also assume that the energies will be the same!!!
            dmono=self.mydata[key].metadata['dspacing']['monochromator_dspacing']
            dana=self.mydata[key].metadata['dspacing']['analyzer_dspacing']
            #print a6
            ei.append(calc_energy(a2,dmono))
            ef.append(calc_energy(a6,dana))
            #print self.length
        self.ei=N.array(ei,'float64')
        self.ef=N.array(ef,'float64')
        #print mydata[key].data.keys()
        return
    def output(self,outputfile=None):
        keys=['pp','mm','pm','mp']
        s=''
        if outputfile!=None:
            f=open(outputfile,'wt')
        for i in range(self.length):
            s=s+'%f %f '%(self.ei[0][i],self.ef[0][i])
            for key in keys:
                if self.counts.has_key(key):
                    s=s+'%f '%(self.counts[key][i],)
                    s=s+'%f '%(self.timestamp[key][i],)
                else:
                    s=s+'* * '
            s=s+'\n'
            print i
        if outputfile==None:
            print s
        else:
            f.write(s)
        if outputfile!=None:
            f.close()
        return

    def savefiles(self):
        mywriter=writebt7.datawriter()
        for key,myfilestr in self.files.iteritems():
            mywriter.write(myoutfilestr=myfilestr+'.out',mydata=self.outdata[key]) 
        return

    
    def correct(self):
        keys=['pp','mm','pm','mp']
        pbinput=PBindata()
        pboutput=PBoutdata()
        pbinput.Ei=self.ei.ctypes.data_as(c_double_p)
        pbinput.Ef=self.ef.ctypes.data_as(c_double_p)
        for key in keys:
            if self.counts.has_key(key):
                if key=='pp':
                    pbinput.tpp=self.timestamp[key].astype('uint32').ctypes.data_as(c_ulong_p)
                    pbinput.Cpp=self.counts[key].ctypes.data_as(c_double_p)
                    pbinput.Epp=self.errors[key].ctypes.data_as(c_double_p)
                if key=='mm':
                    pbinput.tmm=self.timestamp[key].astype('uint32').ctypes.data_as(c_ulong_p)
                    pbinput.Cmm=self.counts[key].ctypes.data_as(c_double_p)
                    pbinput.Emm=self.errors[key].data_as(c_double_p)
                if key=='pm':
                    mytemp_pm=self.timestamp[key].astype('uint32')
                    pbinput.tpm=mytemp_pm.ctypes.data_as(c_ulong_p)
                    print 't0 ',mytemp_pm[0]
                    pbinput.Cpm=self.counts[key].ctypes.data_as(c_double_p)
                    pbinput.Epm=self.errors[key].ctypes.data_as(c_double_p)
                if key=='mp':
                    mytemp_mp=self.timestamp[key].astype('uint32')
                    pbinput.tmp=mytemp_mp.ctypes.data_as(c_ulong_p)
                    pbinput.Cmp=self.counts[key].ctypes.data_as(c_double_p)
                    pbinput.Emp=self.errors[key].ctypes.data_as(c_double_p)
##                tkey='t'+key
##                pbinput[tkey]=
##                ckey='C'+key
##                pbinput[ckey]=self.counts[key].data
##                ekey='E'+key
##                pbinput[ekey]=(N.sqrt(self.counts[key])).data
            else:
##                tkey='t'+key
##                pbinput[tkey]=N.array([],'float64').ctypes.data_as(c_ulong_p)
##                ckey='C'+key
##                pbinput[ckey]=N.array([],'float64').data
##                ekey='E'+key
##                pbinput[ekey]=N.array([],'float64').data
                dummytpp=N.empty((1,self.length),'uint32')
                dummytmm=N.empty((1,self.length),'uint32')
                dummytpm=N.empty((1,self.length),'uint32')
                dummytmp=N.empty((1,self.length),'uint32')
                dummyCpp=N.empty((1,self.length),'float64')
                dummyCmm=N.empty((1,self.length),'float64')
                dummyCpm=N.empty((1,self.length),'float64')
                dummyCmp=N.empty((1,self.length),'float64')
                dummyEpp=N.empty((1,self.length),'float64')
                dummyEmm=N.empty((1,self.length),'float64')
                dummyEpm=N.empty((1,self.length),'float64')
                dummyEmp=N.empty((1,self.length),'float64')

                if key=='pp':
                    pbinput.tpp=dummytpp.ctypes.data_as(c_ulong_p)
                    pbinput.Cpp=dummyCpp.ctypes.data_as(c_double_p)
                    pbinput.Epp=dummyEpp.ctypes.data_as(c_double_p)
                if key=='mm':
                    pbinput.tmm=dummytmm.ctypes.data_as(c_ulong_p)
                    pbinput.Cmm=dummyCmm.ctypes.data_as(c_double_p)
                    pbinput.Emm=dummyEmm.ctypes.data_as(c_double_p)
                if key=='pm':
                    pbinput.tpm=dummytpm.ctypes.data_as(c_ulong_p)
                    pbinput.Cpm=dummyCpm.ctypes.data_as(c_double_p)
                    pbinput.Epm=dummyEpm.ctypes.data_as(c_double_p)
                if key=='mp':
                    pbinput.tmp=dummytmp.ctypes.data_as(c_ulong_p)
                    pbinput.Cmp=dummyCmp.ctypes.data_as(c_double_p)
                    pbinput.Emp=dummyEmp.ctypes.data_as(c_double_p)
               
            

        Spp=N.empty((1,self.length),'float64')
        Smm=N.empty((1,self.length),'float64')
        Spm=N.empty((1,self.length),'float64')
        Smp=N.empty((1,self.length),'float64')
                    
        pboutput.Spp=Spp.ctypes.data_as(c_double_p)
        pboutput.Smm=Smm.ctypes.data_as(c_double_p)
        pboutput.Spm=Spm.ctypes.data_as(c_double_p)
        pboutput.Smp=Smp.ctypes.data_as(c_double_p)



        Epp=N.empty((1,self.length),'float64')
        Emm=N.empty((1,self.length),'float64')
        Epm=N.empty((1,self.length),'float64')
        Emp=N.empty((1,self.length),'float64')
                    
        pboutput.Epp=Epp.ctypes.data_as(c_double_p)
        pboutput.Emm=Emm.ctypes.data_as(c_double_p)
        pboutput.Epm=Epm.ctypes.data_as(c_double_p)
        pboutput.Emp=Emp.ctypes.data_as(c_double_p)
           
        
        pbflags=PBflags()

        fMonitorCorrect=0
        fPolMonitorCorrect=0
        if self.mydata[key].metadata['reference'][1]=='monitor':
            fPolMonitorCorrect=0
            print 'monitor'
        fDebug=0
        fSimFlux=0
        fSimDeviate=0
        #-- ++ +- -+ #TODO Check with Ross on the order
        fCountsEnable=N.ascontiguousarray(N.array([0,0,1,1],int))
        fCountsAdd1=N.ascontiguousarray(N.array([0,0,0,0],'int32'))
        fCountsAdd2=N.ascontiguousarray(N.array([0,0,0,0],'int32'))
        fSconstrain=N.ascontiguousarray(N.array([1,1,0,0],'int32'))
        fSpp=N.ascontiguousarray(N.array([0,0,0,0],'float64'))
        fSmm=N.ascontiguousarray(N.array([0,0,0,0],'float64'))
        fSpm=N.ascontiguousarray(N.array([0,0,0,0],'float64'))
        fSmp=N.ascontiguousarray(N.array([0,0,0,0],'float64'))


##        pbflags.MonitorCorrect=fMonitorCorrect
##        pbflags.PolMonitorCorrect=fPolMonitorCorrect
##        pbflags.Debug=fDebug
##        pbflags.SimFlux=fSimFlux
##        pbflags.SimDeviate=fSimDeviate
##        pbflags.CountsEnable=fCountsEnable.ctypes.data_as(c_int_p)
##        pbflags.CountsAdd1=fCountsAdd1.ctypes.data_as(c_int_p)
##        pbflags.CountsAdd2=fCountsAdd2.ctypes.data_as(c_int_p)
##        pbflags.Sconstrain=fSconstrain.ctypes.data_as(c_int_p)
##        pbflags.Spp=fSpp.ctypes.data_as(c_double_p)
##        pbflags.Smm=fSmm.ctypes.data_as(c_double_p)
##        pbflags.Spm=fSpm.ctypes.data_as(c_double_p)
##        pbflags.Smp=fSmp.ctypes.data_as(c_double_p)
##        mypolcorrect.PBcorrectData(cellP,cellA,ctypes.byref(pbflags),self.length,ctypes.byref(pbinput),ctypes.byref(pboutput))
 
        pbflags.MonitorCorrect=fMonitorCorrect
        pbflags.PolMonitorCorrect=fPolMonitorCorrect
        pbflags.Debug=fDebug
        pbflags.SimFlux=fSimFlux
        pbflags.SimDeviate=fSimDeviate
        pbflags.CountsEnable=fCountsEnable
        pbflags.CountsAdd1=fCountsAdd1
        pbflags.CountsAdd2=fCountsAdd2
        pbflags.Sconstrain=fSconstrain
        pbflags.Spp=fSpp
        pbflags.Smm=fSmm
        pbflags.Spm=fSpm
        pbflags.Smp=fSmp
   
        mypolcorrect.PBcorrectData(cellP,cellA,pbflags._pointer,self.length,ctypes.byref(pbinput),ctypes.byref(pboutput))
#int PBcorrectData(char *PCellFile, char *ACellFile, PBflags *flgs,
#		  int npts, PBindata *in, PBoutdata *out) ;
        #print pboutput.Spm
        print Smp[0]
        print Spm[0]
        corrected_counts={}
        corrected_counts['Spp']=Spp[0]
        corrected_counts['Epp']=Epp[0]

        corrected_counts['Smm']=Smm[0]
        corrected_counts['Emm']=Emm[0]
        
        corrected_counts['Spm']=Spm[0]
        corrected_counts['Epm']=Epm[0]
        
        corrected_counts['Smp']=Smp[0]
        corrected_counts['Emp']=Emp[0]
        self.corrected_counts=corrected_counts
        
        #append corrected counts to our dataset
        self.outdata={}
        for key in keys:
            if self.counts.has_key(key):
                self.outdata[key]=copy.deepcopy(self.mydata[key])
                #self.mydata[key].data[self.mydata[key].metadata['signal']]
                newfield=self.mydata[key].metadata['signal']+'_corrected'
                self.outdata[key].data[newfield]=corrected_counts['S'+key]
                newfield=self.mydata[key].metadata['signal']+'_errs_corrected'
                self.outdata[key].data[newfield]=corrected_counts['E'+key]
            
        #print Epm[0]
        #print Epp[0]
        return corrected_counts




if __name__=="__main__":
    myfilestr_on_off=r'c:\bifeo3xtal\jan8_2008\9175\fieldscansplusminus53566.bt7'
    myfilestr_off_on=r'c:\bifeo3xtal\jan8_2008\9175\fieldscanminusplus53567.bt7'
#    myfilestr_on_off=r'c:\bifeo3xtal\jan8_2008\9175\fieldscansplusminusreset53630.bt7'
#    myfilestr_off_on=r'c:\bifeo3xtal\jan8_2008\9175\fieldscanminusplusreset53631.bt7'

    files={}
    #files['on_on']=myfilestr_on_on
    files['pm']=myfilestr_on_off
    files['mp']=myfilestr_off_on
    #files['off_off']=myfilestr_off_off    
    mypolcor=polarization_correct(files)
    outstr=r'c:\Polarization\pol2.txt'
    mypolcor.output(outstr)
    corrected_counts=mypolcor.correct()
    mypolcor.savefiles()
    #check result
    mydatac={}
    for key,myfilestr in files.iteritems():
        mydatareader=readncnr.datareader()
        mydatac[key]=mydatareader.readbuffer(myfilestr+'.out')
    
    key='pm'
    pylab.subplot(1,2,1)
    pylab.title(key)
    pylab.errorbar(mydatac[key].data['qx'],mydatac[key].data['detector'],mydatac[key].data['detector_errs_corrected'],
                    marker='s',mfc='blue',linestyle='None')     
    pylab.errorbar(mydatac[key].data['qx'],mydatac[key].data['detector_corrected'],N.sqrt(mydatac[key].data['detector']),
                    marker='s',mfc='red',linestyle='None')     
    print 'pm'
    #print mypolcor.mydata[key].data['hsample']    
    key='mp'
    pylab.subplot(1,2,2)
    pylab.title(key)
    print 'mp'
    #print mypolcor.mydata[key].data['hsample']
    print mypolcor.mydata[key].metadata['reference']
    pylab.errorbar(mydatac[key].data['qx'],mydatac[key].data['detector'],mydatac[key].data['detector_errs_corrected'],
                    marker='s',mfc='blue',linestyle='None')     
    pylab.errorbar(mydatac[key].data['qx'],mydatac[key].data['detector_corrected'],N.sqrt(mydatac[key].data['detector']),
                    marker='s',mfc='red',linestyle='None')     
    
    pylab.show()
    